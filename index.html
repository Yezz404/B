<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Chat Records</title>
<!-- Dependencies (CDN) -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/styles/github-dark.min.css">
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.9.3/html2pdf.bundle.min.js"></script>
<!-- Optional: gpt-3-encoder for a more accurate token count if available. If it fails to load, a fallback is used. -->
<script src="https://cdn.jsdelivr.net/npm/gpt-3-encoder@1.1.4/dist/encoder.min.js"></script>

<style>
  :root{
    --bg:#fff9fb;
    --panel:#fff;
    --muted:#8b7d86;
    --accent:#ffd2d2;
    --pink:#ffe4e1;
    --bubble-user:#fff;
    --bubble-assistant:#fffaf0;
    --border:#f1dfe0;
    --text:#222;
    --code-bg:#0b0b0b;
    --scrollbar:#ffb3b3;
  }
  *{box-sizing:border-box;font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;}
  body{margin:0;background:linear-gradient(180deg,var(--bg),#fff);color:var(--text);height:100vh;display:flex;overflow:hidden}
  /* Sidebar */
  .sidebar{width:340px;min-width:260px;background:linear-gradient(0deg,var(--panel),#fff);border-right:1px solid var(--border);padding:16px;display:flex;flex-direction:column;gap:12px}
  .title{font-weight:700;font-size:18px;display:flex;align-items:center;gap:8px}
  .uploadRow{display:flex;gap:8px;align-items:center}
  .btn{background:var(--accent);border-radius:10px;padding:8px 10px;border:1px solid #f5c7c7;cursor:pointer}
  .btn.secondary{background:transparent;border:1px dashed #f5c7c7}
  .controls{display:flex;gap:8px;flex-wrap:wrap}
  .search{display:flex;gap:8px;align-items:center}
  .search input{padding:8px;border-radius:8px;border:1px solid #eee;width:100%}
  .convList{overflow:auto;flex:1;padding-right:6px;margin-top:8px}
  .convItem{padding:10px;border-radius:10px;margin-bottom:8px;border:1px solid transparent;cursor:pointer;display:flex;flex-direction:column;gap:6px}
  .convItem:hover{background:#fff6f6;border-color:#ffe6e6}
  .convTitle{font-weight:600}
  .convMeta{font-size:12px;color:var(--muted)}
  .convStats{font-size:12px;color:var(--muted);display:flex;gap:8px}
  .topbar{display:flex;gap:8px;align-items:center}
  /* Main content */
  .main{flex:1;display:flex;flex-direction:column;height:100vh}
  .header{padding:12px 16px;border-bottom:1px solid var(--border);display:flex;justify-content:space-between;align-items:center;background:linear-gradient(180deg,rgba(255,255,255,0.6),transparent)}
  .chatArea{flex:1;overflow:auto;padding:20px;display:flex;flex-direction:column;gap:16px}
  .controlsRow{display:flex;gap:8px;align-items:center}
  .message{max-width:75%;padding:12px;border-radius:14px;box-shadow:0 1px 0 rgba(0,0,0,0.02);white-space:pre-wrap;word-break:break-word}
  .msgUser{align-self:flex-end;background:var(--bubble-user);border:1px solid #f0e7e7}
  .msgAssistant{align-self:flex-start;background:var(--bubble-assistant);border:1px solid #f3e9e0}
  .msgMeta{font-size:12px;color:var(--muted);margin-bottom:6px}
  .msgActions{display:flex;gap:8px;margin-top:6px}
  .copyBtn{padding:4px 8px;border-radius:8px;border:1px solid #eee;background:transparent;cursor:pointer;font-size:12px}
  pre.codeBlock{background:#111;padding:12px;border-radius:8px;color:#eee;overflow:auto;white-space:pre-wrap;word-wrap:break-word}
  .versionBadge{font-size:11px;padding:4px 6px;border-radius:8px;background:#ffdede;color:#6a0505}
  /* Custom scrollbar */
  ::-webkit-scrollbar{height:10px;width:10px}
  ::-webkit-scrollbar-track{background:transparent}
  ::-webkit-scrollbar-thumb{background:var(--scrollbar);border-radius:8px}
  /* Mobile */
  @media (max-width:900px){
    .sidebar{display:none}
    .main{padding:8px}
  }
  /* small helper */
  .muted{color:var(--muted);font-size:13px}
  .small{font-size:12px;color:var(--muted)}
  .highlight{background:rgba(255,200,200,0.6);padding:2px 3px;border-radius:4px}
  .actionsTop{display:flex;gap:8px;align-items:center}
  .tag{background:#fff2f2;border:1px solid #ffe6e6;padding:4px 6px;border-radius:6px;font-size:12px}
  .filePreview{max-width:320px;border-radius:8px;border:1px solid #eee;padding:6px;margin-bottom:8px}
</style>
</head>
<body>
  <div class="sidebar" id="sidebar">
    <div class="title">Chat Records</div>
    <div class="uploadRow">
      <label class="btn" title="Upload a single conversations.json file">
        Upload JSON<input id="fileJson" type="file" accept=".json" style="display:none">
      </label>
      <label class="btn secondary" title="Upload folder exported by OpenAI (contains conversations.json and attachments)">
        Upload Folder<input id="dirInput" type="file" webkitdirectory directory multiple style="display:none">
      </label>
    </div>

    <div class="controls">
      <div class="search" style="flex:1">
        <input id="globalSearch" placeholder="Search conversations or messages..." />
      </div>
      <div class="actionsTop">
        <button class="btn" id="exportAllTxt">Export All .txt</button>
        <button class="btn" id="exportAllZip">Export Selected .zip</button>
      </div>
    </div>

    <div class="muted small">Sort by:
      <select id="sortSelect">
        <option value="newest">Newest</option>
        <option value="oldest">Oldest</option>
        <option value="az">A - Z</option>
        <option value="za">Z - A</option>
      </select>
    </div>

    <div class="convList" id="convList" aria-live="polite"></div>
    <div class="small muted" id="footerInfo">No file loaded</div>
  </div>

  <div class="main">
    <div class="header">
      <div style="display:flex;align-items:center;gap:12px">
        <div id="convHeaderTitle" style="font-weight:700">Open a conversations.json to begin</div>
        <div id="convHeaderMeta" class="muted small"></div>
      </div>
      <div style="display:flex;align-items:center;gap:8px">
        <button class="btn" id="toggleTheme">Toggle Dark/Light</button>
        <button class="btn" id="downloadConversation" style="display:none">Export .txt</button>
        <button class="btn" id="downloadPDF" style="display:none">Export PDF</button>
        <button class="btn" id="copyConversation" style="display:none">Copy</button>
      </div>
    </div>

    <div class="chatArea" id="chatArea">
      <div class="muted">No conversation selected</div>
    </div>
  </div>

<script>
/*
  Chat Records Viewer
  - Avoids duplicate global variables by attaching a single namespace to window.__ChatExportViewer
  - Robust parsing for old/new OpenAI export formats
  - Renders only user & assistant roles, skips system/tool
  - Multiplies create_time by 1000 if appears to be in seconds
  - Handles folder uploads (attachments: look for files named <id>-<name> or just <name>)
  - Markdown rendering via marked + highlight.js
  - Export single conversation .txt, export selected .zip, export PDF (html2pdf)
  - Search across conversations with preview + keyword highlighting BEFORE opening a conversation
*/

(function(){
  if (window.__ChatExportViewerInitialized) {
    console.warn('Chat viewer already initialized in this page. Reusing instance.');
    return;
  }
  window.__ChatExportViewerInitialized = true;

  // ---------- STATE ----------
  const state = {
    filesMap: new Map(),      // filename -> File
    conversations: [],        // normalized array of conversations
    filteredIndices: [],      // indices visible after search
    currentIndex: null,
    theme: 'light'
  };

  // ---------- HELPERS ----------
  function safeJSONParse(txt){
    try { return JSON.parse(txt); } catch(e) { return null; }
  }

  function isProbablyEpochSeconds(n){
    // returns true if n looks like seconds timestamp (10 digits)
    if (typeof n !== 'number') return false;
    if (n > 1e11) return false; // already ms
    return n > 0;
  }

  function toDate(ts){
    // ts may be seconds or ms; handle both. Ensure not 1970 by checking magnitude
    if (ts == null) return null;
    let n = Number(ts);
    if (Number.isNaN(n)) return null;
    // If n looks like seconds (e.g., < 1e12), assume seconds and multiply
    if (n > 1e12) {
      // already ms
    } else if (n > 1e10) {
      // maybe ms but weird -- treat as ms
    } else {
      n = n * 1000;
    }
    return new Date(n);
  }

  function formatDate(d){
    if (!d) return '';
    // YYYY-MM-DD HH:MM:SS
    const pad = (n) => (n<10 ? '0'+n : n);
    return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
  }

  function ensureArray(x){ return Array.isArray(x) ? x : (x ? [x] : []); }

  // Attempt to extract a message role
  function getMessageRole(msg){
    if (!msg) return 'unknown';
    if (msg.role) return msg.role;
    if (msg.author && msg.author.role) return msg.author.role;
    if (msg.from) return msg.from; // sometimes 'user'/'assistant'
    if (msg.type) return msg.type;
    return 'unknown';
  }

  // Extract textual content from many possible shapes
  function extractMessageText(msg){
    if (!msg) return '';
    // Common OpenAI export shape: msg.content.parts -> array
    if (msg.content){
      if (typeof msg.content === 'string') return msg.content;
      if (Array.isArray(msg.content)) return msg.content.join('\n');
      if (Array.isArray(msg.content?.parts)) return msg.content.parts.join('\n');
      if (typeof msg.content?.text === 'string') return msg.content.text;
      // Some export stores as structured 'cells' or segments
      if (Array.isArray(msg.content?.segments)) {
        return msg.content.segments.map(s => s.text ?? '').join('\n');
      }
    }
    // Older formats: msg.message or msg.text or msg.value
    if (typeof msg.message === 'string') return msg.message;
    if (typeof msg.text === 'string') return msg.text;
    if (typeof msg.value === 'string') return msg.value;
    if (Array.isArray(msg.parts)) return msg.parts.join('\n');
    // fallback: try to stringify a 'content' object
    if (msg.content && typeof msg.content === 'object') {
      // try to pick the first stringy property
      for (const k of ['text','body','value']) {
        if (typeof msg.content[k] === 'string') return msg.content[k];
      }
    }
    return '';
  }

  // detect attachments metadata inside message
  function getMessageAttachments(msg){
    if (!msg) return [];
    const att = [];
    // Typical property names
    for (const key of ['attachments','files','file','media','images']) {
      const v = msg[key];
      if (Array.isArray(v)) {
        v.forEach(a=>{
          if (a && (a.id || a.name || a.filename || a.url)) {
            att.push(a);
          }
        });
      } else if (v && typeof v === 'object' && (v.id || v.name)) {
        att.push(v);
      }
    }
    // sometimes the content contains attachments info
    if (msg.content && Array.isArray(msg.content?.attachments)) {
      msg.content.attachments.forEach(a=>att.push(a));
    }
    // normalize: ensure id and name fields exist
    return att.map(a=>{
      return {
        id: a.id ?? a.file_id ?? a.filename ?? null,
        name: a.name ?? a.filename ?? a.file_name ?? (a.url ? a.url.split('/').pop() : null),
        url: a.url ?? a.href ?? null,
        raw: a
      };
    });
  }

  // Find matching File object in uploaded folder
  function findAttachmentFile(attachment){
    if (!attachment) return null;
    const candidates = [];
    const name = attachment.name;
    const id = attachment.id;
    if (!state.filesMap || state.filesMap.size===0) return null;
    // Try <id>-<name>
    if (id && name) {
      const combined = `${id}-${name}`;
      if (state.filesMap.has(combined)) return state.filesMap.get(combined);
    }
    // Try just name
    if (name && state.filesMap.has(name)) return state.filesMap.get(name);
    // Try name in lower/upper forms
    for (let key of state.filesMap.keys()){
      if (key.endsWith(`-${name}`) || key === name) return state.filesMap.get(key);
      if (name && key.toLowerCase().endsWith(name.toLowerCase())) return state.filesMap.get(key);
    }
    return null;
  }

  // Token counting: use gpt-3-encoder if available, else fallback heuristic
  function countTokens(text){
    if (!text) return 0;
    try {
      if (typeof encode === 'function') {
        return encode(text).length;
      }
    } catch(e){ /* ignore */ }
    // fallback: heuristic: tokens ~ chars/4
    const chars = text.length;
    return Math.max(1, Math.round(chars/4));
  }

  function countWords(text){
    if (!text) return 0;
    return (text.trim().match(/\S+/g) || []).length;
  }

  // ---------- PARSING CONVERSATIONS ----------
  function normalizeConversationsFromParsed(parsed){
    // parsed might be:
    // - an array of conversation objects (old)
    // - an object with items: [] (new)
    // - an object with conversations property
    let items = [];
    if (!parsed) return [];
    if (Array.isArray(parsed)) items = parsed;
    else if (Array.isArray(parsed.items)) items = parsed.items;
    else if (Array.isArray(parsed.conversations)) items = parsed.conversations;
    else {
      // attempt to find first array of objects that look like conversations
      for (const k of Object.keys(parsed)) {
        if (Array.isArray(parsed[k]) && parsed[k].length>0 && typeof parsed[k][0] === 'object') {
          items = parsed[k];
          break;
        }
      }
    }

    // Now normalize each item into an object with id, title, messages[] etc.
    const out = items.map((conv, idx) => {
      // Common fields: title, id, create_time or created_at or updated_at
      const id = conv.id ?? conv.conversation_id ?? `conv-${idx}`;
      const title = conv.title ?? conv.name ?? (conv.metadata?.title) ?? `Conversation ${idx+1}`;
      // messages might be in conv.messages or conv.items or conv.mapping
      let rawMsgs = [];
      if (Array.isArray(conv.messages)) rawMsgs = conv.messages;
      else if (Array.isArray(conv.items)) rawMsgs = conv.items;
      else if (Array.isArray(conv.messages_list)) rawMsgs = conv.messages_list;
      else if (Array.isArray(conv.dialogue)) rawMsgs = conv.dialogue;
      else {
        // try to inspect keys to locate message arrays
        for (const k of Object.keys(conv)) {
          if (Array.isArray(conv[k]) && conv[k].length>0) {
            // Heuristic: message objects should have a role or author or create_time
            const sample = conv[k][0];
            if (sample && (sample.role || sample.author || sample.create_time || sample.content || sample.text || sample.message)) {
              rawMsgs = conv[k];
              break;
            }
          }
        }
      }
      // Normalize each message: preserve original object, compute role, text, timestamp, attachments, versions
      const messages = (rawMsgs || []).map(m => {
        const role = (getMessageRole(m) || '').toString();
        const text = extractMessageText(m) || '';
        const timestamp = (() => {
          // prefer m.create_time or m.created_at or m.timestamp
          if (m.create_time) return m.create_time;
          if (m.created_at) return m.created_at;
          if (m.timestamp) return m.timestamp;
          if (m.date) return m.date;
          return null;
        })();
        const attachments = getMessageAttachments(m);
        // detect edit history / versions - some exports store edits in m.edits or m.versions
        const versions = [];
        if (Array.isArray(m.versions)) {
          m.versions.forEach(v=>{
            versions.push({text: extractMessageText(v), ts: v.create_time || v.timestamp || null, raw:v});
          });
        }
        if (Array.isArray(m.edits)) {
          m.edits.forEach(v=>{
            versions.push({text: extractMessageText(v), ts: v.create_time || v.timestamp || null, raw:v});
          });
        }
        // If the current message has a `content` that is an array of parts representing versions, try to capture them
        if (Array.isArray(m.content?.parts) && m.content.parts.length>1) {
          // keep as single message; but versions might be absent. We won't invent versions here.
        }
        return {
          raw: m,
          role,
          text,
          ts: timestamp,
          date: toDate(timestamp),
          attachments,
          versions,
          modified: !!(m.edited || m.metadata?.modified || m.modified)
        };
      });

      // Compute summary metadata
      const allText = messages.map(mm => mm.text).filter(Boolean).join('\n');
      const userCount = messages.filter(mm => mm.role === 'user').length;
      const assistantCount = messages.filter(mm => mm.role === 'assistant').length;
      const wordCount = countWords(allText);
      const tokenCount = countTokens(allText);

      // find 'last updated' timestamp from messages or conv.update_time or conv.create_time
      let lastDate = null;
      const candidateDates = [];
      if (conv.update_time) candidateDates.push(toDate(conv.update_time));
      if (conv.updated_at) candidateDates.push(toDate(conv.updated_at));
      if (conv.create_time) candidateDates.push(toDate(conv.create_time));
      if (conv.created_at) candidateDates.push(toDate(conv.created_at));
      messages.forEach(m=>{ if (m.date) candidateDates.push(m.date); });
      candidateDates.forEach(d=>{ if (d && (!lastDate || d>lastDate)) lastDate = d; });

      return {
        original: conv,
        id, title,
        messages,
        stats: {userCount, assistantCount, wordCount, tokenCount},
        lastDate: lastDate,
        previewText: allText.slice(0,400)
      };
    });

    return out;
  }

  // ---------- UI RENDER ----------
  const el = {
    fileJson: document.getElementById('fileJson'),
    dirInput: document.getElementById('dirInput'),
    convList: document.getElementById('convList'),
    chatArea: document.getElementById('chatArea'),
    footerInfo: document.getElementById('footerInfo'),
    convHeaderTitle: document.getElementById('convHeaderTitle'),
    convHeaderMeta: document.getElementById('convHeaderMeta'),
    globalSearch: document.getElementById('globalSearch'),
    sortSelect: document.getElementById('sortSelect'),
    downloadConversation: document.getElementById('downloadConversation'),
    downloadPDF: document.getElementById('downloadPDF'),
    copyConversation: document.getElementById('copyConversation'),
    exportAllTxt: document.getElementById('exportAllTxt'),
    exportAllZip: document.getElementById('exportAllZip'),
    toggleTheme: document.getElementById('toggleTheme')
  };

  function clearState(){
    state.filesMap.clear();
    state.conversations = [];
    state.filteredIndices = [];
    state.currentIndex = null;
    el.convList.innerHTML = '';
    el.chatArea.innerHTML = '<div class="muted">No conversation selected</div>';
    el.footerInfo.textContent = 'No file loaded';
    el.convHeaderTitle.textContent = 'Open a conversations.json to begin';
    el.convHeaderMeta.textContent = '';
    hideConversationActions();
  }

  function hideConversationActions(){
    el.downloadConversation.style.display = 'none';
    el.downloadPDF.style.display = 'none';
    el.copyConversation.style.display = 'none';
  }
  function showConversationActions(){
    el.downloadConversation.style.display = '';
    el.downloadPDF.style.display = '';
    el.copyConversation.style.display = '';
  }

  // Render conversation list based on state.filteredIndices (or all)
  function renderConversationList(){
    const list = el.convList;
    list.innerHTML = '';
    const indices = state.filteredIndices.length ? state.filteredIndices : state.conversations.map((_,i)=>i);
    if (!indices.length) {
      list.innerHTML = '<div class="muted small">No conversations found</div>';
      return;
    }
    indices.forEach(i=>{
      const conv = state.conversations[i];
      const div = document.createElement('div');
      div.className = 'convItem';
      div.dataset.index = i;
      const title = document.createElement('div');
      title.className = 'convTitle';
      title.textContent = conv.title || 'Untitled conversation';
      const meta = document.createElement('div');
      meta.className = 'convMeta';
      const dateText = conv.lastDate ? formatDate(conv.lastDate) : '';
      meta.innerHTML = `${dateText} <span style="margin-left:6px">${conv.stats.userCount} user / ${conv.stats.assistantCount} AI • ${conv.stats.wordCount} words • ${conv.stats.tokenCount} tokens</span>`;
      // preview: show snippet with highlighted search terms if any
      const preview = document.createElement('div');
      preview.className = 'small';
      preview.style.whiteSpace = 'nowrap';
      preview.style.overflow = 'hidden';
      preview.style.textOverflow = 'ellipsis';
      const search = el.globalSearch.value.trim();
      if (search) {
        // highlight occurrences in previewText
        const re = new RegExp(escapeRegExp(search), 'ig');
        const txt = conv.previewText.replace(re, (m) => `<span class="highlight">${m}</span>`);
        preview.innerHTML = txt || '';
      } else {
        preview.textContent = conv.previewText || '';
      }

      div.appendChild(title);
      div.appendChild(meta);
      div.appendChild(preview);
      div.addEventListener('click', ()=>openConversation(i));
      list.appendChild(div);
    });
  }

  function escapeRegExp(s){ return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); }

  function openConversation(index){
    state.currentIndex = index;
    const conv = state.conversations[index];
    // Update header
    el.convHeaderTitle.textContent = conv.title || 'Untitled';
    el.convHeaderMeta.textContent = conv.lastDate ? formatDate(conv.lastDate) : '';
    el.footerInfo.textContent = `Parsed ${state.conversations.length} conversations • Showing "${conv.title}"`;
    showConversationActions();
    // Render messages into chatArea
    const area = el.chatArea;
    area.innerHTML = '';
    // compute counts and tokens on the fly
    let aiReplies = 0, userMsgs = 0, totalWords = 0, totalTokens = 0;
    conv.messages.forEach((m, idx) => {
      // Only render user & assistant
      const role = (m.role || '').toLowerCase();
      if (role !== 'user' && role !== 'assistant') return;
      const text = (m.text || '').trim();
      if (!text) return; // skip empty messages per requirements
      const wrapper = document.createElement('div');
      wrapper.className = 'message ' + (role === 'user' ? 'msgUser' : 'msgAssistant');
      // create meta line
      const meta = document.createElement('div');
      meta.className = 'msgMeta';
      meta.textContent = `${role} • ${m.date ? formatDate(m.date) : (m.ts ? m.ts : '')}`;
      wrapper.appendChild(meta);

      // attachments (render before text)
      (m.attachments || []).forEach(att=>{
        const file = findAttachmentFile(att);
        if (file) {
          const preview = renderFilePreview(file);
          wrapper.appendChild(preview);
        } else if (att.url) {
          // show link or embedded if image
          const a = document.createElement('a');
          a.href = att.url;
          a.target = '_blank';
          a.textContent = `Attachment: ${att.name || att.id || att.url}`;
          wrapper.appendChild(a);
        } else {
          const note = document.createElement('div');
          note.className = 'small muted';
          note.textContent = `Attachment metadata: ${att.name || att.id || 'unknown'}`;
          wrapper.appendChild(note);
        }
      });

      // Render text as Markdown into a container
      const mdContainer = document.createElement('div');
      mdContainer.className = 'mdContainer';
      // Use marked to convert to HTML
      // sanitize: we will allow basic HTML but avoid scripts by removing script tags after rendering
      const rendered = marked.parse(text || '');
      mdContainer.innerHTML = rendered;
      // remove script tags if any
      [...mdContainer.querySelectorAll('script')].forEach(s=>s.remove());
      // Syntax highlight code blocks
      mdContainer.querySelectorAll('pre code').forEach(block => {
        try { hljs.highlightElement(block); } catch(e) {}
        // attach copy button for this code block
        const pre = block.closest('pre');
        if (pre) {
          const cp = document.createElement('button');
          cp.className = 'copyBtn';
          cp.textContent = 'Copy code';
          cp.addEventListener('click', ()=> {
            navigator.clipboard.writeText(block.textContent).then(()=> {
              cp.textContent = 'Copied';
              setTimeout(()=>cp.textContent='Copy code', 1200);
            });
          });
          pre.style.position = 'relative';
          cp.style.position = 'absolute';
          cp.style.top = '6px';
          cp.style.right = '6px';
          pre.appendChild(cp);
        }
      });

      wrapper.appendChild(mdContainer);

      // If versions/edit history exist, render them collapsed
      if (m.versions && m.versions.length) {
        const vWrap = document.createElement('div');
        vWrap.className = 'small';
        m.versions.forEach((v, vidx)=>{
          const vb = document.createElement('div');
          vb.innerHTML = `<span class="versionBadge">version ${vidx+1}</span> ${v.ts ? formatDate(toDate(v.ts)) : ''}`;
          const vText = document.createElement('pre');
          vText.style.background = '#fff7f7';
          vText.style.padding = '8px';
          vText.style.borderRadius = '6px';
          vText.style.whiteSpace = 'pre-wrap';
          vText.style.wordWrap = 'break-word';
          vText.textContent = v.text || '';
          vWrap.appendChild(vb);
          vWrap.appendChild(vText);
        });
        wrapper.appendChild(vWrap);
      }
      // action buttons for each message
      const actions = document.createElement('div');
      actions.className = 'msgActions';
      const copyBtn = document.createElement('button');
      copyBtn.className = 'copyBtn';
      copyBtn.textContent = 'Copy message';
      copyBtn.addEventListener('click', ()=>{
        navigator.clipboard.writeText(m.text || '').then(()=> {
          copyBtn.textContent = 'Copied';
          setTimeout(()=>copyBtn.textContent = 'Copy message', 1000);
        });
      });
      actions.appendChild(copyBtn);

      const downloadRawBtn = document.createElement('button');
      downloadRawBtn.className = 'copyBtn';
      downloadRawBtn.textContent = 'Download raw JSON';
      downloadRawBtn.addEventListener('click', ()=>{
        const blob = new Blob([JSON.stringify(m.raw, null, 2)], {type:'application/json'});
        saveAs(blob, `${conv.title || conv.id || 'conversation'}-msg-${idx}.json`);
      });
      actions.appendChild(downloadRawBtn);

      wrapper.appendChild(actions);
      area.appendChild(wrapper);

      // stats
      if (role === 'assistant') aiReplies++;
      if (role === 'user') userMsgs++;
      totalWords += countWords(m.text);
      totalTokens += countTokens(m.text);
    });

    // footer stats in header
    el.convHeaderMeta.textContent = `${conv.stats.userCount} user / ${conv.stats.assistantCount} AI • ${conv.stats.wordCount} words • ${conv.stats.tokenCount} tokens (est)`;
    // Ensure scroll to top
    area.scrollTop = 0;
  }

  // Render file preview for known file types (images, txt, pdf)
  function renderFilePreview(file){
    const wrap = document.createElement('div');
    wrap.className = 'filePreview';
    const url = URL.createObjectURL(file);
    const nameEl = document.createElement('div');
    nameEl.textContent = file.name + ` (${Math.round(file.size/1024)} KB)`;
    nameEl.className = 'small muted';
    wrap.appendChild(nameEl);
    if (file.type.startsWith('image/')) {
      const img = document.createElement('img');
      img.src = url;
      img.style.maxWidth = '100%';
      img.style.borderRadius = '6px';
      wrap.appendChild(img);
    } else if (file.name.endsWith('.txt') || file.type.startsWith('text/')) {
      const p = document.createElement('pre');
      p.style.maxHeight = '160px';
      p.style.overflow = 'auto';
      p.style.whiteSpace = 'pre-wrap';
      // load text asynchronously
      file.text().then(t=>p.textContent = t);
      wrap.appendChild(p);
    } else if (file.name.endsWith('.pdf')) {
      const a = document.createElement('a');
      a.href = url; a.target='_blank'; a.textContent='Open PDF';
      wrap.appendChild(a);
    } else {
      const a = document.createElement('a');
      a.href = url; a.download = file.name; a.textContent = 'Download file';
      wrap.appendChild(a);
    }
    return wrap;
  }

  // ---------- UPLOAD HANDLERS ----------
  el.fileJson.addEventListener('change', async (ev)=>{
    const f = ev.target.files[0];
    if (!f) return;
    clearState();
    state.filesMap.set(f.name, f);
    el.footerInfo.textContent = `Loaded file: ${f.name}`;
    try {
      const txt = await f.text();
      const parsed = safeJSONParse(txt);
      if (!parsed) { el.footerInfo.textContent = 'Failed to parse JSON'; return; }
      const convs = normalizeConversationsFromParsed(parsed);
      state.conversations = convs;
      state.filteredIndices = [];
      el.footerInfo.textContent = `Parsed ${convs.length} conversations from ${f.name}`;
      renderConversationList();
    } catch(e){
      console.error(e);
      el.footerInfo.textContent = 'Error reading file';
    }
    // clear input so re-uploading same file triggers change
    ev.target.value = '';
  });

  el.dirInput.addEventListener('change', async (ev)=>{
    const files = Array.from(ev.target.files || []);
    if (!files.length) return;
    clearState();
    // populate file map
    files.forEach(f => { state.filesMap.set(f.webkitRelativePath || f.name, f); state.filesMap.set(f.name, f); });
    // find conversations.json (case-insensitive)
    const convFile = files.find(f => f.name.toLowerCase() === 'conversations.json');
    if (!convFile) {
      el.footerInfo.textContent = 'No conversations.json found in selected folder.';
      return;
    }
    el.footerInfo.textContent = `Found ${files.length} files. Loading ${convFile.name}`;
    try {
      const txt = await convFile.text();
      const parsed = safeJSONParse(txt);
      if (!parsed) { el.footerInfo.textContent = 'Failed to parse conversations.json'; return; }
      const convs = normalizeConversationsFromParsed(parsed);
      state.conversations = convs;
      state.filteredIndices = [];
      el.footerInfo.textContent = `Parsed ${convs.length} conversations from folder upload`;
      renderConversationList();
    } catch(e){
      console.error(e);
      el.footerInfo.textContent = 'Error reading conversations.json';
    }
    ev.target.value = '';
  });

  // ---------- SEARCH & SORT ----------
  el.globalSearch.addEventListener('input', ()=>{
    applySearchAndFilter();
  });

  el.sortSelect.addEventListener('change', ()=>{
    applySearchAndFilter();
  });

  function applySearchAndFilter(){
    const q = el.globalSearch.value.trim().toLowerCase();
    // sort conversations in place by selection
    const opt = el.sortSelect.value;
    const indices = state.conversations.map((c,i)=>i);
    indices.sort((a,b)=>{
      const ca = state.conversations[a], cb = state.conversations[b];
      if (opt === 'newest') return (cb.lastDate||0) - (ca.lastDate||0);
      if (opt === 'oldest') return (ca.lastDate||0) - (cb.lastDate||0);
      if (opt === 'az') return (ca.title||'').localeCompare(cb.title||'');
      if (opt === 'za') return (cb.title||'').localeCompare(ca.title||'');
      return 0;
    });
    if (!q) {
      state.filteredIndices = indices;
      renderConversationList();
      return;
    }
    const matched = [];
    const re = new RegExp(escapeRegExp(q), 'i');
    indices.forEach(i=>{
      const conv = state.conversations[i];
      // search title
      if ((conv.title||'').toLowerCase().includes(q)) { matched.push(i); return; }
      // search messages' text
      const foundAt = conv.messages.findIndex(m=>{
        if (!m.text) return false;
        if (re.test(m.text)) return true;
        return false;
      });
      if (foundAt >= 0) matched.push(i);
    });
    state.filteredIndices = matched;
    renderConversationList();
  }

  // ---------- EXPORTS ----------
  el.exportAllTxt.addEventListener('click', async ()=>{
    if (!state.conversations.length) return alert('No conversations loaded');
    // generate individual txts and zip them
    const zip = new JSZip();
    state.conversations.forEach((conv, idx)=>{
      const content = conv.messages.filter(m=>['user','assistant'].includes((m.role||'').toLowerCase()))
        .filter(m=>m.text && m.text.trim())
        .map(m=>`${m.role.toUpperCase()} • ${m.date ? formatDate(m.date) : ''}\n${m.text}\n\n`).join('\n');
      zip.file(`${sanitizeFilename(conv.title||conv.id||'conversation')}.txt`, content);
    });
    const blob = await zip.generateAsync({type:'blob'});
    saveAs(blob, 'all-conversations.zip');
  });

  el.exportAllZip.addEventListener('click', async ()=>{
    // allow selecting which to export — for now export all
    el.exportAllTxt.click();
  });

  el.downloadConversation.addEventListener('click', ()=>{
    if (state.currentIndex == null) return;
    const conv = state.conversations[state.currentIndex];
    const text = conv.messages.filter(m=>['user','assistant'].includes((m.role||'').toLowerCase()))
      .filter(m=>m.text && m.text.trim())
      .map(m=>`${m.role.toUpperCase()} • ${m.date ? formatDate(m.date) : ''}\n${m.text}\n`).join('\n\n');
    const blob = new Blob([text], {type:'text/plain;charset=utf-8'});
    saveAs(blob, `${sanitizeFilename(conv.title||conv.id)}.txt`);
  });

  el.copyConversation.addEventListener('click', ()=>{
    if (state.currentIndex == null) return;
    const conv = state.conversations[state.currentIndex];
    const text = conv.messages.filter(m=>['user','assistant'].includes((m.role||'').toLowerCase()))
      .filter(m=>m.text && m.text.trim())
      .map(m=>`${m.role.toUpperCase()} • ${m.date ? formatDate(m.date) : ''}\n${m.text}\n`).join('\n\n');
    navigator.clipboard.writeText(text).then(()=> {
      el.copyConversation.textContent = 'Copied';
      setTimeout(()=>el.copyConversation.textContent = 'Copy', 1000);
    });
  });

  el.downloadPDF.addEventListener('click', ()=>{
    if (state.currentIndex == null) return;
    // convert the visible conversation (.chatArea contents) to PDF
    const node = el.chatArea;
    const opt = {
      margin:       10,
      filename:     `${sanitizeFilename(state.conversations[state.currentIndex].title||'conversation')}.pdf`,
      image:        { type: 'jpeg', quality: 0.98 },
      html2canvas:  { scale: 2, useCORS: true },
      jsPDF:        { unit: 'mm', format: 'a4', orientation: 'portrait' },
      pagebreak:    { mode: ['css', 'legacy'] }
    };
    html2pdf().set(opt).from(node).save();
  });

  function sanitizeFilename(name){
    return (name || 'conversation').replace(/[<>:"/\\|?*\x00-\x1F]/g, '_').slice(0,200);
  }

  // ---------- THEME TOGGLE ----------
  el.toggleTheme.addEventListener('click', ()=>{
    if (state.theme === 'light') {
      document.documentElement.style.setProperty('--bg', '#0b0b0d');
      document.documentElement.style.setProperty('--panel', '#071018');
      document.documentElement.style.setProperty('--muted', '#9aa5b1');
      document.documentElement.style.setProperty('--text', '#e8eef2');
      document.documentElement.style.setProperty('--bubble-user', '#0e1114');
      document.documentElement.style.setProperty('--bubble-assistant', '#071220');
      document.documentElement.style.setProperty('--code-bg', '#000');
      document.documentElement.style.setProperty('--scrollbar', '#ffb3b3');
      state.theme = 'dark';
      document.body.style.color = '#e8eef2';
    } else {
      document.documentElement.style.setProperty('--bg', '#fff9fb');
      document.documentElement.style.setProperty('--panel', '#fff');
      document.documentElement.style.setProperty('--muted', '#8b7d86');
      document.documentElement.style.setProperty('--text', '#222');
      document.documentElement.style.setProperty('--bubble-user', '#fff');
      document.documentElement.style.setProperty('--bubble-assistant', '#fffaf0');
      document.documentElement.style.setProperty('--code-bg', '#0b0b0b');
      document.documentElement.style.setProperty('--scrollbar', '#ffb3b3');
      state.theme = 'light';
      document.body.style.color = '#222';
    }
  });

  // ---------- Utility to open conversation by default if only one ----------
  function openFirstIfAny(){
    if (state.conversations.length === 1) openConversation(0);
  }

  // ---------- Initialize small UI state ----------
  clearState();

  // Expose some helpers to window for debugging if needed, but avoid polluting with big vars
  window.ChatRecordsViewer = {
    state,
    openConversation,
    normalizeConversationsFromParsed
  };

  // Small UX: allow dropping a conversations.json onto the page
  document.addEventListener('dragover', (e)=>{ e.preventDefault(); });
  document.addEventListener('drop', (e)=>{
    e.preventDefault();
    const f = e.dataTransfer.files && e.dataTransfer.files[0];
    if (!f) return;
    if (f.name.toLowerCase().endsWith('.json')) {
      el.fileJson.files = e.dataTransfer.files;
      const evt = new Event('change');
      el.fileJson.dispatchEvent(evt);
    }
  });

  // Helpful note
  console.info('Chat Records Viewer ready. Upload a conversations.json (single file) or the exported folder.');

})(); // end IIFE
</script>
</body>
</html>